#include "KMP.h"

void getnext(char* pattern, int* next, int patternLength)
{
        int i = 0;
        int j = -1;
        next[0] = -1;
        //这里先给一个next[0]=-1，因为反正next数组的开头是固定的，所以给定值的方法一直适用。

        while (i < patternLength - 1)//当这个字符串的元素还没有遍历到最后一个得时候，继续循环
        {
            //当j=-1的时候，i和j同时加加，当j=-1的时候表示，这个字符串的第0个元素和现在正在匹配的1元素也不相同，
            //这个时候让j=-1，然后两个同时加加，就让这个字符串的第0个元素和正在匹配的下一个元素开始比较
            //每当这个元素匹配的时候，就让next[i]=j，
            if (j == -1 || pattern[i] == pattern[j]) //当j=-1的时候，或者当pattern的第i个元素等于pattern的
                //第j个元素的时候
            {//第一次进行if判断的时候，i=0，j=-1；，因为当j=-1的时候后面是||所以直接停止第二步的判断
                //执行i++，和j++，现在的i=1，j=0
                //然后next[1]=0
                i++;
                j++;
                next[i] = j;
                
            }
            else {
                //如果不符合判断的条件，直接让j=next[j]。以下以google为例子
                //当i=1，j=0时，进入else，然后j=next[1],就是j=1，然后再进入循环，进入上面的if语句后面的内容
                //然后i=2，j=2，next[2]=2
                j = next[j];
            }
        }
       
        //这里不需要对每个元素进行加一，因为在c语言中，字符串的下表是从0开始的。
        // 如果假设字符串的下表是从1开始的，那么这个next数组就要将0位置处的元素设置为空，同时整体的元素向后退一位
        //  int f = 0;
        //i = 0;
        //for (f = 0; f < patternLength; f++)
        //{
        //    next[i] = next[i] + 1;
        //    //这里让每个元素加一
        //    i++;
        //}
}
//这里的情况是模式串的字符串的元素的下标从1开始的结果
//当j=0的时候，会通过一定步骤协调i加一所以不会出现cchar的第0位元素和其他的元素一起比的结果。
//但是c语言里面的数组或者字符的元素的开始的下标固定为0；所以这里从0开始
int compatute(char* mainl, char* cchar, int next[])
{
    int i = 0, j = 0;
    while (i<strlen(mainl)&&(j+1)<(strlen(cchar)+1))//这两个字符串都还没有遍历完成的时候，就一直循环
    {//这里一直出现问题（现在已经修正），在c语言中不能直接对比-1和1的大小，其他的负数和正数的比较也相同
        //因为j最小就是-1，所以这里让j+1成为正数，同时strlen(cchar)也+1再比较，保持这两个之间的差值不变
        if(j==-1||mainl[i]==cchar[j])
        {
            //当j=-1的时候，或者主字符串的第i位和模式字符串的第j个元素相同的时候，i++，j++
            //当j=-1的时候，next数组的（-1）位置没有元素，i++，j++，就相当于，让next[j]指向next数组的第一个元素，next[0]
            //next[0]=-1；
            // 但是现在if已经判断完毕一次，再进行一次循环，如果mainl[i]不等于cchar[0]的话，
            // 执行else里面的内容，也就是再让j=next[0]=-1；然后再返回到这个注释最开始的情况。
            //也就是当模式字符串的第一个元素，和主字符串的元素不匹配的时候，让i++，j=1，也就是让主字符串的下一个元素和模式字符串的第一个元素进行匹配
            //注意这里的模式字符串第一个元素是从0开始的.
            i++;
            j++;
            //虽然有j=next[j]这样的调用，但是j=-1的时候，就会执行i++和j++，所以无论调用next[j]和cchar[j]都不会调用的下标为1的情况

        }
        else
        {
            j = next[j];
            //上面的注释有
        }
    }
    if (j > strlen(next))
    {
        return i - strlen(cchar);
        //当遍历得到最后的一位元素相同的时候，i-模式字符串的长度就是这个字符串的开始的位置的个数
    }
    else
        return 0;
}
